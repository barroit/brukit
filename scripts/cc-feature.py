#!/usr/bin/python3
# SPDX-License-Identifier: GPL-3.0-or-later or MIT

import atexit
import multiprocessing as mp
import platform
import textwrap

from libkit import *

from os import path

if argc < 2:
	die('missing generation type')

type = argv[1]

srctree = env_or_die('SRCTREE')
gendir = env_or_die('GENDIR')
objtree = env_or_die('OBJTREE')
cc = env_or_die('CC')

os_name = platform.system()

cdef = open(f"{srctree}/scripts/cc-feature.def", 'r')

if type == 'cmake':
	dst = open(f"{objtree}/features.cmake", 'w')
elif type == 'header':
	dst = open(f"{gendir}/features.h", 'w')
else:
	die(f"unknown type {arg}")

pid = getpid()
tmp = f".tmp_{pid}.o"

def echo_pref_cmake():
	dst.write(textwrap.dedent(f"""\
	# Generated by scripts/cc-feature.py {type} on {os_name}

	"""))

def echo_pref_header():
	dst.write(textwrap.dedent(f"""\
	/*
	 * Generated by scripts/cc-feature.py {type} on {os_name}
	 */

	#ifdef CONFIG_ENABLE_WCHAR
	# define UNICODE
	#endif
	"""))

def echo_def_cmake(name, ret):
	if ret == 0:
		dst.write(f"\nset({name} 1)\n")
	else:
		dst.write(f"\n# unset({name})\n")

def echo_def_header(name, ret):
	if ret == 0:
		dst.write(f"\n#define {name}\n")
	else:
		dst.write(f"\n/* #undef {name} */\n")

if type == 'cmake':
	echo_pref = echo_pref_cmake
	echo_def  = echo_def_cmake
else:
	echo_pref = echo_pref_header
	echo_def  = echo_def_header

def rmtmp():
	if path.isfile(tmp):
		unlink(tmp)

atexit.register(rmtmp)

def test_feature(name, prog):
	if prog[0] == '\n':
		cmd = [ cc, '-Werror', '-S', '-x', 'c', '-o', devnull, '-' ]
	else:
		cmd  = [ cc, '-Werror', '-c', '-x', 'c', '-o', tmp, devnull ]
		cmd[1:1] = prog.split()

	res = execl(cmd, text=True, input=prog, capture_output=True)

	return (name, res.returncode)

def test_feature_cb(rets):
	echo_pref()

	for name, ret in rets:
		echo_def(name, ret)

# BEGIN	Because Windows fucking sucks.
if __name__ == '__main__':
# END	Because Windows fucking sucks.

	tests = {}

	exec(cdef.read(), {}, tests)

	pool = mp.Pool(mp.cpu_count() + 1)
	args = [(name, tests[name]) for name in tests]

	pool.starmap_async(test_feature, args, callback = test_feature_cb)

	pool.close()
	pool.join()
